/* ==========================================================================================

   ,ad8888ba,    ,ad8888ba,    88        88  888b      88  
  d8"'    `"8b  d8"'    `"8b   88        88  8888b     88  
 d8'           d8'        `8b  88        88  88 `8b    88  
 88            88          88  88aaaaaaaa88  88  `8b   88  
 88            88          88  88""""""""88  88   `8b  88  
 Y8,           Y8,        ,8P  88        88  88    `8b 88  
  Y8a.    .a8P  Y8a.    .a8P   88        88  88     `8888  
   `"Y8888Y"'    `"Y8888Y"'    88        88  88      `888  

 ===========================================================================================
 ===========================================================================================
 =============== BRAND / MARKETING / DIGITAL / PR      =====================================
 ===========================================================================================
 =============== D E N V E R   C O L O R A D O   U S A =====================================
 ===========================================================================================*/
/*  Theme Name: Pena Station Next
/*  Version: 1.0.0
/*  Author: Paul Wood | COHN
/*  Author URI: http://cohnmarketing.com
/*  Description: A WordPress project created by COHN.
/*  Text Domain: penastationnext
/* ========================================================================================== */
/*  Copyright © 2019. Pena Station Next All rights reserved.
/* ========================================================================================== */

///////////////////////////////
// Classie
///////////////////////////////
/*!
 * classie v1.0.1
 * class helper functions
 * from bonzo https://github.com/ded/bonzo
 * MIT license
 *
 * classie.has( elem, 'my-class' ) -> true/false
 * classie.add( elem, 'my-new-class' )
 * classie.remove( elem, 'my-unwanted-class' )
 * classie.toggle( elem, 'my-class' )
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false */

(function( window ) {

'use strict';

// class helper functions from bonzo https://github.com/ded/bonzo

function classReg( className ) {
  return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
}

// classList support for class management
// altho to be fair, the api sucks because it won't accept multiple classes at once
var hasClass, addClass, removeClass;

if ( 'classList' in document.documentElement ) {
  hasClass = function( elem, c ) {
    return elem.classList.contains( c );
  };
  addClass = function( elem, c ) {
    elem.classList.add( c );
  };
  removeClass = function( elem, c ) {
    elem.classList.remove( c );
  };
}
else {
  hasClass = function( elem, c ) {
    return classReg( c ).test( elem.className );
  };
  addClass = function( elem, c ) {
    if ( !hasClass( elem, c ) ) {
      elem.className = elem.className + ' ' + c;
    }
  };
  removeClass = function( elem, c ) {
    elem.className = elem.className.replace( classReg( c ), ' ' );
  };
}

function toggleClass( elem, c ) {
  var fn = hasClass( elem, c ) ? removeClass : addClass;
  fn( elem, c );
}

var classie = {
  // full names
  hasClass: hasClass,
  addClass: addClass,
  removeClass: removeClass,
  toggleClass: toggleClass,
  // short names
  has: hasClass,
  add: addClass,
  remove: removeClass,
  toggle: toggleClass
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( classie );
} else if ( typeof exports === 'object' ) {
  // CommonJS
  module.exports = classie;
} else {
  // browser global
  window.classie = classie;
}

})( window );

/*!
Waypoints - 4.0.0
Copyright © 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function(){"use strict";function t(o){if(!o)throw new Error("No options passed to Waypoint constructor");if(!o.element)throw new Error("No element option passed to Waypoint constructor");if(!o.handler)throw new Error("No handler option passed to Waypoint constructor");this.key="waypoint-"+e,this.options=t.Adapter.extend({},t.defaults,o),this.element=this.options.element,this.adapter=new t.Adapter(this.element),this.callback=o.handler,this.axis=this.options.horizontal?"horizontal":"vertical",this.enabled=this.options.enabled,this.triggerPoint=null,this.group=t.Group.findOrCreate({name:this.options.group,axis:this.axis}),this.context=t.Context.findOrCreateByElement(this.options.context),t.offsetAliases[this.options.offset]&&(this.options.offset=t.offsetAliases[this.options.offset]),this.group.add(this),this.context.add(this),i[this.key]=this,e+=1}var e=0,i={};t.prototype.queueTrigger=function(t){this.group.queueTrigger(this,t)},t.prototype.trigger=function(t){this.enabled&&this.callback&&this.callback.apply(this,t)},t.prototype.destroy=function(){this.context.remove(this),this.group.remove(this),delete i[this.key]},t.prototype.disable=function(){return this.enabled=!1,this},t.prototype.enable=function(){return this.context.refresh(),this.enabled=!0,this},t.prototype.next=function(){return this.group.next(this)},t.prototype.previous=function(){return this.group.previous(this)},t.invokeAll=function(t){var e=[];for(var o in i)e.push(i[o]);for(var n=0,r=e.length;r>n;n++)e[n][t]()},t.destroyAll=function(){t.invokeAll("destroy")},t.disableAll=function(){t.invokeAll("disable")},t.enableAll=function(){t.invokeAll("enable")},t.refreshAll=function(){t.Context.refreshAll()},t.viewportHeight=function(){return window.innerHeight||document.documentElement.clientHeight},t.viewportWidth=function(){return document.documentElement.clientWidth},t.adapters=[],t.defaults={context:window,continuous:!0,enabled:!0,group:"default",horizontal:!1,offset:0},t.offsetAliases={"bottom-in-view":function(){return this.context.innerHeight()-this.adapter.outerHeight()},"right-in-view":function(){return this.context.innerWidth()-this.adapter.outerWidth()}},window.Waypoint=t}(),function(){"use strict";function t(t){window.setTimeout(t,1e3/60)}function e(t){this.element=t,this.Adapter=n.Adapter,this.adapter=new this.Adapter(t),this.key="waypoint-context-"+i,this.didScroll=!1,this.didResize=!1,this.oldScroll={x:this.adapter.scrollLeft(),y:this.adapter.scrollTop()},this.waypoints={vertical:{},horizontal:{}},t.waypointContextKey=this.key,o[t.waypointContextKey]=this,i+=1,this.createThrottledScrollHandler(),this.createThrottledResizeHandler()}var i=0,o={},n=window.Waypoint,r=window.onload;e.prototype.add=function(t){var e=t.options.horizontal?"horizontal":"vertical";this.waypoints[e][t.key]=t,this.refresh()},e.prototype.checkEmpty=function(){var t=this.Adapter.isEmptyObject(this.waypoints.horizontal),e=this.Adapter.isEmptyObject(this.waypoints.vertical);t&&e&&(this.adapter.off(".waypoints"),delete o[this.key])},e.prototype.createThrottledResizeHandler=function(){function t(){e.handleResize(),e.didResize=!1}var e=this;this.adapter.on("resize.waypoints",function(){e.didResize||(e.didResize=!0,n.requestAnimationFrame(t))})},e.prototype.createThrottledScrollHandler=function(){function t(){e.handleScroll(),e.didScroll=!1}var e=this;this.adapter.on("scroll.waypoints",function(){(!e.didScroll||n.isTouch)&&(e.didScroll=!0,n.requestAnimationFrame(t))})},e.prototype.handleResize=function(){n.Context.refreshAll()},e.prototype.handleScroll=function(){var t={},e={horizontal:{newScroll:this.adapter.scrollLeft(),oldScroll:this.oldScroll.x,forward:"right",backward:"left"},vertical:{newScroll:this.adapter.scrollTop(),oldScroll:this.oldScroll.y,forward:"down",backward:"up"}};for(var i in e){var o=e[i],n=o.newScroll>o.oldScroll,r=n?o.forward:o.backward;for(var s in this.waypoints[i]){var a=this.waypoints[i][s],l=o.oldScroll<a.triggerPoint,h=o.newScroll>=a.triggerPoint,p=l&&h,u=!l&&!h;(p||u)&&(a.queueTrigger(r),t[a.group.id]=a.group)}}for(var c in t)t[c].flushTriggers();this.oldScroll={x:e.horizontal.newScroll,y:e.vertical.newScroll}},e.prototype.innerHeight=function(){return this.element==this.element.window?n.viewportHeight():this.adapter.innerHeight()},e.prototype.remove=function(t){delete this.waypoints[t.axis][t.key],this.checkEmpty()},e.prototype.innerWidth=function(){return this.element==this.element.window?n.viewportWidth():this.adapter.innerWidth()},e.prototype.destroy=function(){var t=[];for(var e in this.waypoints)for(var i in this.waypoints[e])t.push(this.waypoints[e][i]);for(var o=0,n=t.length;n>o;o++)t[o].destroy()},e.prototype.refresh=function(){var t,e=this.element==this.element.window,i=e?void 0:this.adapter.offset(),o={};this.handleScroll(),t={horizontal:{contextOffset:e?0:i.left,contextScroll:e?0:this.oldScroll.x,contextDimension:this.innerWidth(),oldScroll:this.oldScroll.x,forward:"right",backward:"left",offsetProp:"left"},vertical:{contextOffset:e?0:i.top,contextScroll:e?0:this.oldScroll.y,contextDimension:this.innerHeight(),oldScroll:this.oldScroll.y,forward:"down",backward:"up",offsetProp:"top"}};for(var r in t){var s=t[r];for(var a in this.waypoints[r]){var l,h,p,u,c,d=this.waypoints[r][a],f=d.options.offset,w=d.triggerPoint,y=0,g=null==w;d.element!==d.element.window&&(y=d.adapter.offset()[s.offsetProp]),"function"==typeof f?f=f.apply(d):"string"==typeof f&&(f=parseFloat(f),d.options.offset.indexOf("%")>-1&&(f=Math.ceil(s.contextDimension*f/100))),l=s.contextScroll-s.contextOffset,d.triggerPoint=y+l-f,h=w<s.oldScroll,p=d.triggerPoint>=s.oldScroll,u=h&&p,c=!h&&!p,!g&&u?(d.queueTrigger(s.backward),o[d.group.id]=d.group):!g&&c?(d.queueTrigger(s.forward),o[d.group.id]=d.group):g&&s.oldScroll>=d.triggerPoint&&(d.queueTrigger(s.forward),o[d.group.id]=d.group)}}return n.requestAnimationFrame(function(){for(var t in o)o[t].flushTriggers()}),this},e.findOrCreateByElement=function(t){return e.findByElement(t)||new e(t)},e.refreshAll=function(){for(var t in o)o[t].refresh()},e.findByElement=function(t){return o[t.waypointContextKey]},window.onload=function(){r&&r(),e.refreshAll()},n.requestAnimationFrame=function(e){var i=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||t;i.call(window,e)},n.Context=e}(),function(){"use strict";function t(t,e){return t.triggerPoint-e.triggerPoint}function e(t,e){return e.triggerPoint-t.triggerPoint}function i(t){this.name=t.name,this.axis=t.axis,this.id=this.name+"-"+this.axis,this.waypoints=[],this.clearTriggerQueues(),o[this.axis][this.name]=this}var o={vertical:{},horizontal:{}},n=window.Waypoint;i.prototype.add=function(t){this.waypoints.push(t)},i.prototype.clearTriggerQueues=function(){this.triggerQueues={up:[],down:[],left:[],right:[]}},i.prototype.flushTriggers=function(){for(var i in this.triggerQueues){var o=this.triggerQueues[i],n="up"===i||"left"===i;o.sort(n?e:t);for(var r=0,s=o.length;s>r;r+=1){var a=o[r];(a.options.continuous||r===o.length-1)&&a.trigger([i])}}this.clearTriggerQueues()},i.prototype.next=function(e){this.waypoints.sort(t);var i=n.Adapter.inArray(e,this.waypoints),o=i===this.waypoints.length-1;return o?null:this.waypoints[i+1]},i.prototype.previous=function(e){this.waypoints.sort(t);var i=n.Adapter.inArray(e,this.waypoints);return i?this.waypoints[i-1]:null},i.prototype.queueTrigger=function(t,e){this.triggerQueues[e].push(t)},i.prototype.remove=function(t){var e=n.Adapter.inArray(t,this.waypoints);e>-1&&this.waypoints.splice(e,1)},i.prototype.first=function(){return this.waypoints[0]},i.prototype.last=function(){return this.waypoints[this.waypoints.length-1]},i.findOrCreate=function(t){return o[t.axis][t.name]||new i(t)},n.Group=i}(),function(){"use strict";function t(t){this.$element=e(t)}var e=window.jQuery,i=window.Waypoint;e.each(["innerHeight","innerWidth","off","offset","on","outerHeight","outerWidth","scrollLeft","scrollTop"],function(e,i){t.prototype[i]=function(){var t=Array.prototype.slice.call(arguments);return this.$element[i].apply(this.$element,t)}}),e.each(["extend","inArray","isEmptyObject"],function(i,o){t[o]=e[o]}),i.adapters.push({name:"jquery",Adapter:t}),i.Adapter=t}(),function(){"use strict";function t(t){return function(){var i=[],o=arguments[0];return t.isFunction(arguments[0])&&(o=t.extend({},arguments[1]),o.handler=arguments[0]),this.each(function(){var n=t.extend({},o,{element:this});"string"==typeof n.context&&(n.context=t(this).closest(n.context)[0]),i.push(new e(n))}),i}}var e=window.Waypoint;window.jQuery&&(window.jQuery.fn.waypoint=t(window.jQuery)),window.Zepto&&(window.Zepto.fn.waypoint=t(window.Zepto))}();
/**
 * jQuery jCookies
 *
 * @url		http://scottreeddesign.com/project/jcookies-jquery-plugin
 * @author	Brian Reed <brian@scottreeddesign.com>
 * @version	1.0.0
**/
(function($){

	// Main plugin function
	$.jCookies = function(options)
	{
		// Build main options before element iteration
		var o = $.extend({}, $.jCookies.defaults, options);

	// set raw_data for get or erase
		if(o.get || o.erase){

			var raw_data = {}, name = '', names = [];
			var ca = document.cookie.split(';');
			for(var i = 0;i<ca.length;i++){
				var c = ca[i];
				while(c.charAt(0) == ' ') c = c.substring(1,c.length);
				name = c.split('=')[0];
				if(name.length == 0) break;
				raw_data[name] = c.substring((name.length+1), c.length);
				names[names.length] = name;
			}

		// erase cookie(s)
			if(o.erase){

				var date = new Date();
				date.setTime(date.getTime() + (-1*24*60*60*1000));
			// erase multiple cookies
				if(o.erase == '*') {
					for(name in raw_data)
						document.cookie = name + "=erase; expires=" + date.toGMTString() + "; path=/";
					return true;
				}

			// erase single cookie
				for(name in names)
					if(names[name] == o.erase){
						document.cookie = o.erase + "=erase; expires=" + date.toGMTString() + "; path=/";
						return true;
					}

				return false;

			}

		// get cookie(s)
			else if(o.get){
				// get multiple cookies
				if(o.get == "*" && raw_data) {
					for(name in raw_data)
						try{
							raw_data[name] = JSON.parse(atob(raw_data[name]));
						}catch(exception){
							try{
								raw_data[name] = JSON.parse(atob(decodeURIComponent(raw_data[name])));
							}catch(exception2){
								if(o.error) return exception2;
							}
							if(o.error) return exception;
						}
					return raw_data;
				}

			// get single cookies
				for(x in names)
					if(names[x] == o.get)
					try{
						return JSON.parse(atob(raw_data[o.get]));
					}catch(exception){
						if(o.error) return exception;
					}

				return false;

			}

		}
	// make cookie(s)
		else if(o.name && (o.value || o.days)){

			var date = new Date();
			if(!isNaN(o.seconds)){
				date.setTime(date.getTime() + (o.seconds*1000));
			}else if(!isNaN(o.minutes)){
				date.setTime(date.getTime() + (o.minutes*60*1000));
			}else if(!isNaN(o.hours)){
				date.setTime(date.getTime() + (o.hours*60*60*1000));
			}else{
				date.setTime(date.getTime() + (o.days*24*60*60*1000));
			}
			document.cookie = o.name + "=" + btoa(JSON.stringify(o.value)) + "; expires=" + date.toGMTString() + "; path=/";
			return true;
	// get cookie
		} else return false;
	}

	// Default settings
	$.jCookies.defaults =
	{
		name : '',
		value : '',
		days : 27
	}

})(jQuery);

/*! lazysizes - v4.1.5 */
!function(a,b){var c=b(a,a.document);a.lazySizes=c,"object"==typeof module&&module.exports&&(module.exports=c)}(window,function(a,b){"use strict";if(b.getElementsByClassName){var c,d,e=b.documentElement,f=a.Date,g=a.HTMLPictureElement,h="addEventListener",i="getAttribute",j=a[h],k=a.setTimeout,l=a.requestAnimationFrame||k,m=a.requestIdleCallback,n=/^picture$/i,o=["load","error","lazyincluded","_lazyloaded"],p={},q=Array.prototype.forEach,r=function(a,b){return p[b]||(p[b]=new RegExp("(\\s|^)"+b+"(\\s|$)")),p[b].test(a[i]("class")||"")&&p[b]},s=function(a,b){r(a,b)||a.setAttribute("class",(a[i]("class")||"").trim()+" "+b)},t=function(a,b){var c;(c=r(a,b))&&a.setAttribute("class",(a[i]("class")||"").replace(c," "))},u=function(a,b,c){var d=c?h:"removeEventListener";c&&u(a,b),o.forEach(function(c){a[d](c,b)})},v=function(a,d,e,f,g){var h=b.createEvent("Event");return e||(e={}),e.instance=c,h.initEvent(d,!f,!g),h.detail=e,a.dispatchEvent(h),h},w=function(b,c){var e;!g&&(e=a.picturefill||d.pf)?(c&&c.src&&!b[i]("srcset")&&b.setAttribute("srcset",c.src),e({reevaluate:!0,elements:[b]})):c&&c.src&&(b.src=c.src)},x=function(a,b){return(getComputedStyle(a,null)||{})[b]},y=function(a,b,c){for(c=c||a.offsetWidth;c<d.minSize&&b&&!a._lazysizesWidth;)c=b.offsetWidth,b=b.parentNode;return c},z=function(){var a,c,d=[],e=[],f=d,g=function(){var b=f;for(f=d.length?e:d,a=!0,c=!1;b.length;)b.shift()();a=!1},h=function(d,e){a&&!e?d.apply(this,arguments):(f.push(d),c||(c=!0,(b.hidden?k:l)(g)))};return h._lsFlush=g,h}(),A=function(a,b){return b?function(){z(a)}:function(){var b=this,c=arguments;z(function(){a.apply(b,c)})}},B=function(a){var b,c=0,e=d.throttleDelay,g=d.ricTimeout,h=function(){b=!1,c=f.now(),a()},i=m&&g>49?function(){m(h,{timeout:g}),g!==d.ricTimeout&&(g=d.ricTimeout)}:A(function(){k(h)},!0);return function(a){var d;(a=!0===a)&&(g=33),b||(b=!0,d=e-(f.now()-c),d<0&&(d=0),a||d<9?i():k(i,d))}},C=function(a){var b,c,d=99,e=function(){b=null,a()},g=function(){var a=f.now()-c;a<d?k(g,d-a):(m||e)(e)};return function(){c=f.now(),b||(b=k(g,d))}};!function(){var b,c={lazyClass:"lazyload",loadedClass:"lazyloaded",loadingClass:"lazyloading",preloadClass:"lazypreload",errorClass:"lazyerror",autosizesClass:"lazyautosizes",srcAttr:"data-src",srcsetAttr:"data-srcset",sizesAttr:"data-sizes",minSize:40,customMedia:{},init:!0,expFactor:1.5,hFac:.8,loadMode:2,loadHidden:!0,ricTimeout:0,throttleDelay:125};d=a.lazySizesConfig||a.lazysizesConfig||{};for(b in c)b in d||(d[b]=c[b]);a.lazySizesConfig=d,k(function(){d.init&&F()})}();var D=function(){var g,l,m,o,p,y,D,F,G,H,I,J=/^img$/i,K=/^iframe$/i,L="onscroll"in a&&!/(gle|ing)bot/.test(navigator.userAgent),M=0,N=0,O=0,P=-1,Q=function(a){O--,a&&a.target&&u(a.target,Q),(!a||O<0||!a.target)&&(O=0)},R=function(a,c){var d,f=a,g="hidden"==x(b.body,"visibility")||"hidden"!=x(a.parentNode,"visibility")&&"hidden"!=x(a,"visibility");for(F-=c,I+=c,G-=c,H+=c;g&&(f=f.offsetParent)&&f!=b.body&&f!=e;)(g=(x(f,"opacity")||1)>0)&&"visible"!=x(f,"overflow")&&(d=f.getBoundingClientRect(),g=H>d.left&&G<d.right&&I>d.top-1&&F<d.bottom+1);return g},S=function(){var a,f,h,j,k,m,n,p,q,r,s,t,u=c.elements;if((o=d.loadMode)&&O<8&&(a=u.length)){for(f=0,P++,r=!d.expand||d.expand<1?e.clientHeight>500&&e.clientWidth>500?500:370:d.expand,s=r*d.expFactor,t=d.hFac,N<s&&O<1&&P>2&&o>2&&!b.hidden?(N=s,P=0):N=o>1&&P>1&&O<6?r:M;f<a;f++)if(u[f]&&!u[f]._lazyRace)if(L)if((p=u[f][i]("data-expand"))&&(m=1*p)||(m=N),q!==m&&(y=innerWidth+m*t,D=innerHeight+m,n=-1*m,q=m),h=u[f].getBoundingClientRect(),(I=h.bottom)>=n&&(F=h.top)<=D&&(H=h.right)>=n*t&&(G=h.left)<=y&&(I||H||G||F)&&(d.loadHidden||"hidden"!=x(u[f],"visibility"))&&(l&&O<3&&!p&&(o<3||P<4)||R(u[f],m))){if($(u[f]),k=!0,O>9)break}else!k&&l&&!j&&O<4&&P<4&&o>2&&(g[0]||d.preloadAfterLoad)&&(g[0]||!p&&(I||H||G||F||"auto"!=u[f][i](d.sizesAttr)))&&(j=g[0]||u[f]);else $(u[f]);j&&!k&&$(j)}},T=B(S),U=function(a){s(a.target,d.loadedClass),t(a.target,d.loadingClass),u(a.target,W),v(a.target,"lazyloaded")},V=A(U),W=function(a){V({target:a.target})},X=function(a,b){try{a.contentWindow.location.replace(b)}catch(c){a.src=b}},Y=function(a){var b,c=a[i](d.srcsetAttr);(b=d.customMedia[a[i]("data-media")||a[i]("media")])&&a.setAttribute("media",b),c&&a.setAttribute("srcset",c)},Z=A(function(a,b,c,e,f){var g,h,j,l,o,p;(o=v(a,"lazybeforeunveil",b)).defaultPrevented||(e&&(c?s(a,d.autosizesClass):a.setAttribute("sizes",e)),h=a[i](d.srcsetAttr),g=a[i](d.srcAttr),f&&(j=a.parentNode,l=j&&n.test(j.nodeName||"")),p=b.firesLoad||"src"in a&&(h||g||l),o={target:a},p&&(u(a,Q,!0),clearTimeout(m),m=k(Q,2500),s(a,d.loadingClass),u(a,W,!0)),l&&q.call(j.getElementsByTagName("source"),Y),h?a.setAttribute("srcset",h):g&&!l&&(K.test(a.nodeName)?X(a,g):a.src=g),f&&(h||l)&&w(a,{src:g})),a._lazyRace&&delete a._lazyRace,t(a,d.lazyClass),z(function(){(!p||a.complete&&a.naturalWidth>1)&&(p?Q(o):O--,U(o))},!0)}),$=function(a){var b,c=J.test(a.nodeName),e=c&&(a[i](d.sizesAttr)||a[i]("sizes")),f="auto"==e;(!f&&l||!c||!a[i]("src")&&!a.srcset||a.complete||r(a,d.errorClass)||!r(a,d.lazyClass))&&(b=v(a,"lazyunveilread").detail,f&&E.updateElem(a,!0,a.offsetWidth),a._lazyRace=!0,O++,Z(a,b,f,e,c))},_=function(){if(!l){if(f.now()-p<999)return void k(_,999);var a=C(function(){d.loadMode=3,T()});l=!0,d.loadMode=3,T(),j("scroll",function(){3==d.loadMode&&(d.loadMode=2),a()},!0)}};return{_:function(){p=f.now(),c.elements=b.getElementsByClassName(d.lazyClass),g=b.getElementsByClassName(d.lazyClass+" "+d.preloadClass),j("scroll",T,!0),j("resize",T,!0),a.MutationObserver?new MutationObserver(T).observe(e,{childList:!0,subtree:!0,attributes:!0}):(e[h]("DOMNodeInserted",T,!0),e[h]("DOMAttrModified",T,!0),setInterval(T,999)),j("hashchange",T,!0),["focus","mouseover","click","load","transitionend","animationend","webkitAnimationEnd"].forEach(function(a){b[h](a,T,!0)}),/d$|^c/.test(b.readyState)?_():(j("load",_),b[h]("DOMContentLoaded",T),k(_,2e4)),c.elements.length?(S(),z._lsFlush()):T()},checkElems:T,unveil:$}}(),E=function(){var a,c=A(function(a,b,c,d){var e,f,g;if(a._lazysizesWidth=d,d+="px",a.setAttribute("sizes",d),n.test(b.nodeName||""))for(e=b.getElementsByTagName("source"),f=0,g=e.length;f<g;f++)e[f].setAttribute("sizes",d);c.detail.dataAttr||w(a,c.detail)}),e=function(a,b,d){var e,f=a.parentNode;f&&(d=y(a,f,d),e=v(a,"lazybeforesizes",{width:d,dataAttr:!!b}),e.defaultPrevented||(d=e.detail.width)&&d!==a._lazysizesWidth&&c(a,f,e,d))},f=function(){var b,c=a.length;if(c)for(b=0;b<c;b++)e(a[b])},g=C(f);return{_:function(){a=b.getElementsByClassName(d.autosizesClass),j("resize",g)},checkElems:g,updateElem:e}}(),F=function(){F.i||(F.i=!0,E._(),D._())};return c={cfg:d,autoSizer:E,loader:D,init:F,uP:w,aC:s,rC:t,hC:r,fire:v,gW:y,rAF:z}}});
/*
This plugin extends lazySizes to lazyLoad:
background images, videos/posters and scripts

Background-Image:
For background images, use data-bg attribute:
<div class="lazyload" data-bg="bg-img.jpg"></div>

 Video:
 For video/audio use data-poster and preload="none":
 <video class="lazyload" data-poster="poster.jpg" preload="none">
 <!-- sources -->
 </video>

 Scripts:
 For scripts use data-script:
 <div class="lazyload" data-script="module-name.js"></div>


 Script modules using require:
 For modules using require use data-require:
 <div class="lazyload" data-require="module-name"></div>
*/

(function(window, factory) {
	var globalInstall = function(){
		factory(window.lazySizes);
		window.removeEventListener('lazyunveilread', globalInstall, true);
	};

	factory = factory.bind(null, window, window.document);

	if(typeof module == 'object' && module.exports){
		factory(require('lazysizes'));
	} else if(window.lazySizes) {
		globalInstall();
	} else {
		window.addEventListener('lazyunveilread', globalInstall, true);
	}
}(window, function(window, document, lazySizes) {
	/*jshint eqnull:true */
	'use strict';
	var bgLoad, regBgUrlEscape;
	var uniqueUrls = {};

	if(document.addEventListener){
		regBgUrlEscape = /\(|\)|\s|'/;

		bgLoad = function (url, cb){
			var img = document.createElement('img');
			img.onload = function(){
				img.onload = null;
				img.onerror = null;
				img = null;
				cb();
			};
			img.onerror = img.onload;

			img.src = url;

			if(img && img.complete && img.onload){
				img.onload();
			}
		};

		addEventListener('lazybeforeunveil', function(e){
			if(e.detail.instance != lazySizes){return;}

			var tmp, load, bg, poster;
			if(!e.defaultPrevented) {

				if(e.target.preload == 'none'){
					e.target.preload = 'auto';
				}

				tmp = e.target.getAttribute('data-link');
				if(tmp){
					addStyleScript(tmp, true);
				}

				// handle data-script
				tmp = e.target.getAttribute('data-script');
				if(tmp){
					addStyleScript(tmp);
				}

				// handle data-require
				tmp = e.target.getAttribute('data-require');
				if(tmp){
					if(lazySizes.cfg.requireJs){
						lazySizes.cfg.requireJs([tmp]);
					} else {
						addStyleScript(tmp);
					}
				}

				// handle data-bg
				bg = e.target.getAttribute('data-bg');
				if (bg) {
					e.detail.firesLoad = true;
					load = function(){
						e.target.style.backgroundImage = 'url(' + (regBgUrlEscape.test(bg) ? JSON.stringify(bg) : bg ) + ')';
						e.detail.firesLoad = false;
						lazySizes.fire(e.target, '_lazyloaded', {}, true, true);
					};

					bgLoad(bg, load);
				}

				// handle data-poster
				poster = e.target.getAttribute('data-poster');
				if(poster){
					e.detail.firesLoad = true;
					load = function(){
						e.target.poster = poster;
						e.detail.firesLoad = false;
						lazySizes.fire(e.target, '_lazyloaded', {}, true, true);
					};

					bgLoad(poster, load);

				}
			}
		}, false);

	}

	function addStyleScript(src, style){
		if(uniqueUrls[src]){
			return;
		}
		var elem = document.createElement(style ? 'link' : 'script');
		var insertElem = document.getElementsByTagName('script')[0];

		if(style){
			elem.rel = 'stylesheet';
			elem.href = src;
		} else {
			elem.src = src;
		}
		uniqueUrls[src] = true;
		uniqueUrls[elem.src || elem.href] = true;
		insertElem.parentNode.insertBefore(elem, insertElem);
	}
}));

/**
 *
 * Version: 1.0.0
 * Author: Gianluca Guarini
 * Contact: gianluca.guarini@gmail.com
 * Website: http://www.gianlucaguarini.com/
 * Twitter: @gianlucaguarini
 *
 * Copyright (c) Gianluca Guarini
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 **/
(function(doc, win) {
  'use strict'
  if (typeof doc.createEvent !== 'function') return false // no tap events here
  // helpers
  var useJquery = typeof jQuery !== 'undefined',
    msEventType = function(type) {
      var lo = type.toLowerCase(),
        ms = 'MS' + type
      return navigator.msPointerEnabled ? ms : lo
    },
    // was initially triggered a "touchstart" event?
    wasTouch = false,
    touchevents = {
      touchstart: msEventType('PointerDown') + ' touchstart',
      touchend: msEventType('PointerUp') + ' touchend',
      touchmove: msEventType('PointerMove') + ' touchmove'
    },
    setListener = function(elm, events, callback) {
      var eventsArray = events.split(' '),
        i = eventsArray.length

      while (i--) {
        elm.addEventListener(eventsArray[i], callback, false)
      }
    },
    getPointerEvent = function(event) {
      return event.targetTouches ? event.targetTouches[0] : event
    },
    getTimestamp = function () {
      return new Date().getTime()
    },
    sendEvent = function(elm, eventName, originalEvent, data) {
      var customEvent = doc.createEvent('Event')
      customEvent.originalEvent = originalEvent
      data = data || {}
      data.x = currX
      data.y = currY
      data.distance = data.distance

      // jquery
      if (useJquery) {
        customEvent = jQuery.Event(eventName, {originalEvent: originalEvent})
        jQuery(elm).trigger(customEvent, data)
      }

      // addEventListener
      if (customEvent.initEvent) {
        for (var key in data) {
          customEvent[key] = data[key]
        }
        customEvent.initEvent(eventName, true, true)
        elm.dispatchEvent(customEvent)
      }

      // detect all the inline events
      // also on the parent nodes
      while (elm) {
        // inline
        if (elm['on' + eventName])
          elm['on' + eventName](customEvent)
        elm = elm.parentNode
      }

    },

    onTouchStart = function(e) {
      /**
       * Skip all the mouse events
       * events order:
       * Chrome:
       *   touchstart
       *   touchmove
       *   touchend
       *   mousedown
       *   mousemove
       *   mouseup <- this must come always after a "touchstart"
       *
       * Safari
       *   touchstart
       *   mousedown
       *   touchmove
       *   mousemove
       *   touchend
       *   mouseup <- this must come always after a "touchstart"
       */

      // it looks like it was a touch event!
      if (e.type !== 'mousedown')
        wasTouch = true

      // skip this event we don't need to track it now
      if (e.type === 'mousedown' && wasTouch) return

      var pointer = getPointerEvent(e)

      // caching the current x
      cachedX = currX = pointer.pageX
      // caching the current y
      cachedY = currY = pointer.pageY

      longtapTimer = setTimeout(function() {
        sendEvent(e.target, 'longtap', e)
        target = e.target
      }, longtapThreshold)

      // we will use these variables on the touchend events
      timestamp = getTimestamp()

      tapNum++

    },
    onTouchEnd = function(e) {

      // skip the mouse events if previously a touch event was dispatched
      // and reset the touch flag
      if (e.type === 'mouseup' && wasTouch) {
        wasTouch = false
        return
      }

      var eventsArr = [],
        now = getTimestamp(),
        deltaY = cachedY - currY,
        deltaX = cachedX - currX

       // clear the previous timer if it was set
      clearTimeout(dblTapTimer)
      // kill the long tap timer
      clearTimeout(longtapTimer)

      if (deltaX <= -swipeThreshold)
        eventsArr.push('swiperight')

      if (deltaX >= swipeThreshold)
        eventsArr.push('swipeleft')

      if (deltaY <= -swipeThreshold)
        eventsArr.push('swipedown')

      if (deltaY >= swipeThreshold)
        eventsArr.push('swipeup')

      if (eventsArr.length) {
        for (var i = 0; i < eventsArr.length; i++) {
          var eventName = eventsArr[i]
          sendEvent(e.target, eventName, e, {
            distance: {
              x: Math.abs(deltaX),
              y: Math.abs(deltaY)
            }
          })
        }
        // reset the tap counter
        tapNum = 0
      } else {

        if (
          cachedX >= currX - tapPrecision &&
          cachedX <= currX + tapPrecision &&
          cachedY >= currY - tapPrecision &&
          cachedY <= currY + tapPrecision
        ) {
          if (timestamp + tapThreshold - now >= 0)
          {
            // Here you get the Tap event
            sendEvent(e.target, tapNum >= 2 && target === e.target ? 'dbltap' : 'tap', e)
            target= e.target
          }
        }

        // reset the tap counter
        dblTapTimer = setTimeout(function() {
          tapNum = 0
        }, dbltapThreshold)

      }
    },
    onTouchMove = function(e) {
      // skip the mouse move events if the touch events were previously detected
      if (e.type === 'mousemove' && wasTouch) return

      var pointer = getPointerEvent(e)
      currX = pointer.pageX
      currY = pointer.pageY
    },
    swipeThreshold = win.SWIPE_THRESHOLD || 100,
    tapThreshold = win.TAP_THRESHOLD || 150, // range of time where a tap event could be detected
    dbltapThreshold = win.DBL_TAP_THRESHOLD || 200, // delay needed to detect a double tap
    longtapThreshold = win.LONG_TAP_THRESHOLD || 1000, // delay needed to detect a long tap
    tapPrecision = win.TAP_PRECISION / 2 || 60 / 2, // touch events boundaries ( 60px by default )
    justTouchEvents = win.JUST_ON_TOUCH_DEVICES,
    tapNum = 0,
    currX, currY, cachedX, cachedY, timestamp, target, dblTapTimer, longtapTimer

  //setting the events listeners
  // we need to debounce the callbacks because some devices multiple events are triggered at same time
  setListener(doc, touchevents.touchstart + (justTouchEvents ? '' : ' mousedown'), onTouchStart)
  setListener(doc, touchevents.touchend + (justTouchEvents ? '' : ' mouseup'), onTouchEnd)
  setListener(doc, touchevents.touchmove + (justTouchEvents ? '' : ' mousemove'), onTouchMove)

}(document, window));

//
// // ------------------------------------------
// // Rellax.js
// // Buttery smooth parallax library
// // Copyright (c) 2016 Moe Amaya (@moeamaya)
// // MIT license
// //
// // Thanks to Paraxify.js and Jaime Cabllero
// // for parallax concepts
// // ------------------------------------------
//
// (function (root, factory) {
//   if (typeof define === 'function' && define.amd) {
//     // AMD. Register as an anonymous module.
//     define([], factory);
//   } else if (typeof module === 'object' && module.exports) {
//     // Node. Does not work with strict CommonJS, but
//     // only CommonJS-like environments that support module.exports,
//     // like Node.
//     module.exports = factory();
//   } else {
//     // Browser globals (root is window)
//     root.Rellax = factory();
//   }
// }(typeof window !== "undefined" ? window : global, function () {
//   var Rellax = function(el, options){
//     "use strict";
//
//     var self = Object.create(Rellax.prototype);
//
//     var posY = 0;
//     var screenY = 0;
//     var posX = 0;
//     var screenX = 0;
//     var blocks = [];
//     var pause = true;
// 
//     // check what requestAnimationFrame to use, and if
//     // it's not supported, use the onscroll event
//     var loop = window.requestAnimationFrame ||
//       window.webkitRequestAnimationFrame ||
//       window.mozRequestAnimationFrame ||
//       window.msRequestAnimationFrame ||
//       window.oRequestAnimationFrame ||
//       function(callback){ return setTimeout(callback, 1000 / 60); };
//
//     // store the id for later use
//     var loopId = null;
//
//     // check what cancelAnimation method to use
//     var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;
//
//     // check which transform property to use
//     var transformProp = window.transformProp || (function(){
//         var testEl = document.createElement('div');
//         if (testEl.style.transform === null) {
//           var vendors = ['Webkit', 'Moz', 'ms'];
//           for (var vendor in vendors) {
//             if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {
//               return vendors[vendor] + 'Transform';
//             }
//           }
//         }
//         return 'transform';
//       })();
//
//     // Default Settings
//     self.options = {
//       speed: -2,
//       center: false,
//       wrapper: null,
//       relativeToWrapper: false,
//       round: true,
//       vertical: true,
//       horizontal: false,
//       callback: function() {},
//     };
//
//     // User defined options (might have more in the future)
//     if (options){
//       Object.keys(options).forEach(function(key){
//         self.options[key] = options[key];
//       });
//     }
//
//     // By default, rellax class
//     if (!el) {
//       el = '.rellax';
//     }
//
//     // check if el is a className or a node
//     var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];
//
//     // Now query selector
//     if (elements.length > 0) {
//       self.elems = elements;
//     }
//
//     // The elements don't exist
//     else {
//       throw new Error("The elements you're trying to select don't exist.");
//     }
//
//     // Has a wrapper and it exists
//     if (self.options.wrapper) {
//       if (!self.options.wrapper.nodeType) {
//         var wrapper = document.querySelector(self.options.wrapper);
//
//         if (wrapper) {
//           self.options.wrapper = wrapper;
//         } else {
//           throw new Error("The wrapper you're trying to use don't exist.");
//         }
//       }
//     }
//
//
//     // Get and cache initial position of all elements
//     var cacheBlocks = function() {
//       for (var i = 0; i < self.elems.length; i++){
//         var block = createBlock(self.elems[i]);
//         blocks.push(block);
//       }
//     };
//
//
//     // Let's kick this script off
//     // Build array for cached element values
//     var init = function() {
//       for (var i = 0; i < blocks.length; i++){
//         self.elems[i].style.cssText = blocks[i].style;
//       }
//
//       blocks = [];
//
//       screenY = window.innerHeight;
//       screenX = window.innerWidth;
//       setPosition();
//
//       cacheBlocks();
//
//       // If paused, unpause and set listener for window resizing events
//       if (pause) {
//         window.addEventListener('resize', init);
//         pause = false;
//       }
//       animate();
//     };
//
//     // We want to cache the parallax blocks'
//     // values: base, top, height, speed
//     // el: is dom object, return: el cache values
//     var createBlock = function(el) {
//       var dataPercentage = el.getAttribute( 'data-rellax-percentage' );
//       var dataSpeed = el.getAttribute( 'data-rellax-speed' );
//       var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;
//       var dataMin = el.getAttribute( 'data-rellax-min' );
//       var dataMax = el.getAttribute( 'data-rellax-max' );
//
//       // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)
//       // ensures elements are positioned based on HTML layout.
//       //
//       // If the element has the percentage attribute, the posY and posX needs to be
//       // the current scroll position's value, so that the elements are still positioned based on HTML layout
//       var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
//       // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.
//       if (self.options.relativeToWrapper) {
//         var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
//         wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;
//       }
//       var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;
//       var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;
//
//       var blockTop = posY + el.getBoundingClientRect().top;
//       var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;
//
//       var blockLeft = posX + el.getBoundingClientRect().left;
//       var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;
//
//       // apparently parallax equation everyone uses
//       var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);
//       var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);
//       if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }
//
//       // Optional individual block speed as data attr, otherwise global speed
//       var speed = dataSpeed ? dataSpeed : self.options.speed;
//
//       var bases = updatePosition(percentageX, percentageY, speed);
//
//       // ~~Store non-translate3d transforms~~
//       // Store inline styles and extract transforms
//       var style = el.style.cssText;
//       var transform = '';
//
//       // Check if there's an inline styled transform
//       if (style.indexOf('transform') >= 0) {
//         // Get the index of the transform
//         var index = style.indexOf('transform');
//
//         // Trim the style to the transform point and get the following semi-colon index
//         var trimmedStyle = style.slice(index);
//         var delimiter = trimmedStyle.indexOf(';');
//
//         // Remove "transform" string and save the attribute
//         if (delimiter) {
//           transform = " " + trimmedStyle.slice(11, delimiter).replace(/\s/g,'');
//         } else {
//           transform = " " + trimmedStyle.slice(11).replace(/\s/g,'');
//         }
//       }
//
//       return {
//         baseX: bases.x,
//         baseY: bases.y,
//         top: blockTop,
//         left: blockLeft,
//         height: blockHeight,
//         width: blockWidth,
//         speed: speed,
//         style: style,
//         transform: transform,
//         zindex: dataZindex,
//         min: dataMin,
//         max: dataMax
//       };
//     };
//
//     // set scroll position (posY, posX)
//     // side effect method is not ideal, but okay for now
//     // returns true if the scroll changed, false if nothing happened
//     var setPosition = function() {
//       var oldY = posY;
//       var oldX = posX;
//
//       posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
//       posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;
//       // If option relativeToWrapper is true, use relative wrapper value instead.
//       if (self.options.relativeToWrapper) {
//         var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
//         posY = scrollPosY - self.options.wrapper.offsetTop;
//       }
//
//
//       if (oldY != posY && self.options.vertical) {
//         // scroll changed, return true
//         return true;
//       }
//
//       if (oldX != posX && self.options.horizontal) {
//         // scroll changed, return true
//         return true;
//       }
//
//       // scroll did not change
//       return false;
//     };
//
//     // Ahh a pure function, gets new transform value
//     // based on scrollPosition and speed
//     // Allow for decimal pixel values
//     var updatePosition = function(percentageX, percentageY, speed) {
//       var result = {};
//       var valueX = (speed * (100 * (1 - percentageX)));
//       var valueY = (speed * (100 * (1 - percentageY)));
//
//       result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;
//       result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;
//
//       return result;
//     };
//
//     // Loop
//     var update = function() {
//       if (setPosition() && pause === false) {
//         animate();
//       }
//
//       // loop again
//       loopId = loop(update);
//     };
//
//     // Transform3d on parallax element
//     var animate = function() {
//       var positions;
//       for (var i = 0; i < self.elems.length; i++){
//         var percentageY = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));
//         var percentageX = ((posX - blocks[i].left + screenX) / (blocks[i].width + screenX));
//
//         // Subtracting initialize value, so element stays in same spot as HTML
//         positions = updatePosition(percentageX, percentageY, blocks[i].speed);// - blocks[i].baseX;
//         var positionY = positions.y - blocks[i].baseY;
//         var positionX = positions.x - blocks[i].baseX;
//
//         // The next two "if" blocks go like this:
//         // Check if a limit is defined (first "min", then "max");
//         // Check if we need to change the Y or the X
//         // (Currently working only if just one of the axes is enabled)
//         // Then, check if the new position is inside the allowed limit
//         // If so, use new position. If not, set position to limit.
//
//         // Check if a min limit is defined
//         if (blocks[i].min !== null) {
//           if (self.options.vertical && !self.options.horizontal) {
//             positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;
//           }
//           if (self.options.horizontal && !self.options.vertical) {
//             positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;
//           }
//         }
//
//         // Check if a max limit is defined
//         if (blocks[i].max !== null) {
//           if (self.options.vertical && !self.options.horizontal) {
//             positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;
//           }
//           if (self.options.horizontal && !self.options.vertical) {
//             positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;
//           }
//         }
//
//         var zindex = blocks[i].zindex;
//
//         // Move that element
//         // (Set the new translation and append initial inline transforms.)
//
//         // var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;
//         var translate = 'translate3d(' + (self.options.vertical ? positionX : '0') + 'px,' + '0' + 'px,' + zindex + 'px) ' + blocks[i].transform;
//
//         self.elems[i].style[transformProp] = translate;
//       }
//       self.options.callback(positions);
//     };
//
//     self.destroy = function() {
//       for (var i = 0; i < self.elems.length; i++){
//         self.elems[i].style.cssText = blocks[i].style;
//       }
//
//       // Remove resize event listener if not pause, and pause
//       if (!pause) {
//         window.removeEventListener('resize', init);
//         pause = true;
//       }
//
//       // Clear the animation loop to prevent possible memory leak
//       clearLoop(loopId);
//       loopId = null;
//     };
//
//     // Init
//     init();
//
//     // Start the loop
//     update();
//
//     // Allow to recalculate the initial values whenever we want
//     self.refresh = init;
//
//     return self;
//   };
//   return Rellax;
// }));

// (function(h,g){"function"===typeof define&&define.amd?define([],g):"object"===typeof module&&module.exports?module.exports=g():h.Rellax=g()})(typeof window !== "undefined" ? window : global,function(){var h=function(g,n){var a=Object.create(h.prototype),k=0,p=0,l=0,q=0,e=[],r=!0,z=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||function(a){setTimeout(a,1E3/60)},A=window.transformProp||function(){var a=document.createElement("div");
// if(null===a.style.transform){var b=["Webkit","Moz","ms"],d;for(d in b)if(void 0!==a.style[b[d]+"Transform"])return b[d]+"Transform"}return"transform"}();a.options={speed:-2,center:!1,wrapper:null,round:!0,vertical:!0,horizontal:!1,callback:function(){}};n&&Object.keys(n).forEach(function(c){a.options[c]=n[c]});g||(g=".rellax");var m="string"===typeof g?document.querySelectorAll(g):[g];if(0<m.length)a.elems=m;else throw Error("The elements you're trying to select don't exist.");if(a.options.wrapper&&
// !a.options.wrapper.nodeType)if(m=document.querySelector(a.options.wrapper))a.options.wrapper=m;else throw Error("The wrapper you're trying to use don't exist.");var u=function(){for(var c=0;c<e.length;c++)a.elems[c].style.cssText=e[c].style;e=[];p=window.innerHeight;q=window.innerWidth;v();for(c=0;c<a.elems.length;c++){var b=a.elems[c],d=b.getAttribute("data-rellax-percentage"),t=b.getAttribute("data-rellax-speed"),g=b.getAttribute("data-rellax-zindex")||0,h=a.options.wrapper?a.options.wrapper.scrollTop:
// window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,f=a.options.vertical?d||a.options.center?h:0:0,k=a.options.horizontal?d||a.options.center?window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft:0:0;h=f+b.getBoundingClientRect().top;var l=b.clientHeight||b.offsetHeight||b.scrollHeight,m=k+b.getBoundingClientRect().left,n=b.clientWidth||b.offsetWidth||b.scrollWidth;f=d?d:(f-h+p)/(l+p);d=d?d:(k-m+q)/(n+q);a.options.center&&(f=d=.5);t=t?t:a.options.speed;
// d=w(d,f,t);b=b.style.cssText;f="";0<=b.indexOf("transform")&&(f=b.indexOf("transform"),f=b.slice(f),f=(k=f.indexOf(";"))?" "+f.slice(11,k).replace(/\s/g,""):" "+f.slice(11).replace(/\s/g,""));e.push({baseX:d.x,baseY:d.y,top:h,left:m,height:l,width:n,speed:t,style:b,transform:f,zindex:g})}r&&(window.addEventListener("resize",u),r=!1);x()},v=function(){var c=k,b=l;k=a.options.wrapper?a.options.wrapper.scrollTop:(document.documentElement||document.body.parentNode||document.body).scrollTop||window.pageYOffset;
// l=a.options.wrapper?a.options.wrapper.scrollLeft:(document.documentElement||document.body.parentNode||document.body).scrollLeft||window.pageXOffset;return c!=k&&a.options.vertical||b!=l&&a.options.horizontal?!0:!1},w=function(c,b,d){var e={};c=100*d*(1-c);b=100*d*(1-b);e.x=a.options.round?Math.round(c):Math.round(100*c)/100;e.y=a.options.round?Math.round(b):Math.round(100*b)/100;return e},y=function(){v()&&!1===r&&x();z(y)},x=function(){for(var c,b=0;b<a.elems.length;b++){c=w((l-e[b].left+q)/(e[b].width+
// q),(k-e[b].top+p)/(e[b].height+p),e[b].speed);var d=c.y-e[b].baseY,g=c.x-e[b].baseX;a.elems[b].style[A]="translate3d("+(a.options.horizontal?g:"0")+"px,"+(a.options.vertical?d:"0")+"px,"+e[b].zindex+"px) "+e[b].transform}a.options.callback(c)};a.destroy=function(){for(var c=0;c<a.elems.length;c++)a.elems[c].style.cssText=e[c].style;r||(window.removeEventListener("resize",u),r=!0)};u();y();a.refresh=u;return a};return h});

/*!
Waypoints Sticky Element Shortcut - 4.0.0
Copyright © 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function(){"use strict";function t(s){this.options=e.extend({},i.defaults,t.defaults,s),this.element=this.options.element,this.$element=e(this.element),this.createWrapper(),this.createWaypoint()}var e=window.jQuery,i=window.Waypoint;t.prototype.createWaypoint=function(){var t=this.options.handler;this.waypoint=new i(e.extend({},this.options,{element:this.wrapper,handler:e.proxy(function(e){var i=this.options.direction.indexOf(e)>-1,s=i?this.$element.outerHeight(!0):"";this.$wrapper.height(s),this.$element.toggleClass(this.options.stuckClass,i),t&&t.call(this,e)},this)}))},t.prototype.createWrapper=function(){this.options.wrapper&&this.$element.wrap(this.options.wrapper),this.$wrapper=this.$element.parent(),this.wrapper=this.$wrapper[0]},t.prototype.destroy=function(){this.$element.parent()[0]===this.wrapper&&(this.waypoint.destroy(),this.$element.removeClass(this.options.stuckClass),this.options.wrapper&&this.$element.unwrap())},t.defaults={wrapper:'<div class="sticky-wrapper" />',stuckClass:"stuck",direction:"down right"},i.Sticky=t}();

// ------------------------------------------
// Rellax.js
// Buttery smooth parallax library
// Copyright (c) 2016 Moe Amaya (@moeamaya)
// MIT license
//
// Thanks to Paraxify.js and Jaime Cabllero
// for parallax concepts
// ------------------------------------------

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.Rellax = factory();
  }
}(typeof window !== "undefined" ? window : global, function () {
  var Rellax = function(el, options){
    "use strict";

    var self = Object.create(Rellax.prototype);

    var posY = 0;
    var screenY = 0;
    var posX = 0;
    var screenX = 0;
    var blocks = [];
    var pause = true;

    // check what requestAnimationFrame to use, and if
    // it's not supported, use the onscroll event
    var loop = window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      function(callback){ return setTimeout(callback, 1000 / 60); };

    // store the id for later use
    var loopId = null;

    // check what cancelAnimation method to use
    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;

    // check which transform property to use
    var transformProp = window.transformProp || (function(){
        var testEl = document.createElement('div');
        if (testEl.style.transform === null) {
          var vendors = ['Webkit', 'Moz', 'ms'];
          for (var vendor in vendors) {
            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {
              return vendors[vendor] + 'Transform';
            }
          }
        }
        return 'transform';
      })();

    // Default Settings
    self.options = {
      speed: -2,
      center: false,
      wrapper: null,
      relativeToWrapper: false,
      round: true,
      vertical: true,
      horizontal: false,
      callback: function() {},
    };

    // User defined options (might have more in the future)
    if (options){
      Object.keys(options).forEach(function(key){
        self.options[key] = options[key];
      });
    }

    // By default, rellax class
    if (!el) {
      el = '.rellax';
    }

    // check if el is a className or a node
    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];

    // Now query selector
    if (elements.length > 0) {
      self.elems = elements;
    }

    // The elements don't exist
    else {
      throw new Error("The elements you're trying to select don't exist.");
    }

    // Has a wrapper and it exists
    if (self.options.wrapper) {
      if (!self.options.wrapper.nodeType) {
        var wrapper = document.querySelector(self.options.wrapper);

        if (wrapper) {
          self.options.wrapper = wrapper;
        } else {
          throw new Error("The wrapper you're trying to use don't exist.");
        }
      }
    }


    // Get and cache initial position of all elements
    var cacheBlocks = function() {
      for (var i = 0; i < self.elems.length; i++){
        var block = createBlock(self.elems[i]);
        blocks.push(block);
      }
    };


    // Let's kick this script off
    // Build array for cached element values
    var init = function() {
      for (var i = 0; i < blocks.length; i++){
        self.elems[i].style.cssText = blocks[i].style;
      }

      blocks = [];

      screenY = window.innerHeight;
      screenX = window.innerWidth;
      setPosition();

      cacheBlocks();

      // If paused, unpause and set listener for window resizing events
      if (pause) {
        window.addEventListener('resize', init);
        pause = false;
      }
      animate();
    };

    // We want to cache the parallax blocks'
    // values: base, top, height, speed
    // el: is dom object, return: el cache values
    var createBlock = function(el) {
      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );
      var dataSpeed = el.getAttribute( 'data-rellax-speed' );
      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;
      var dataMin = el.getAttribute( 'data-rellax-min' );
      var dataMax = el.getAttribute( 'data-rellax-max' );

      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)
      // ensures elements are positioned based on HTML layout.
      //
      // If the element has the percentage attribute, the posY and posX needs to be
      // the current scroll position's value, so that the elements are still positioned based on HTML layout
      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.
      if (self.options.relativeToWrapper) {
        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;
      }
      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;
      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;

      var blockTop = posY + el.getBoundingClientRect().top;
      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;

      var blockLeft = posX + el.getBoundingClientRect().left;
      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;

      // apparently parallax equation everyone uses
      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);
      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);
      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }

      // Optional individual block speed as data attr, otherwise global speed
      var speed = dataSpeed ? dataSpeed : self.options.speed;

      var bases = updatePosition(percentageX, percentageY, speed);

      // ~~Store non-translate3d transforms~~
      // Store inline styles and extract transforms
      var style = el.style.cssText;
      var transform = '';

      // Check if there's an inline styled transform
      if (style.indexOf('transform') >= 0) {
        // Get the index of the transform
        var index = style.indexOf('transform');

        // Trim the style to the transform point and get the following semi-colon index
        var trimmedStyle = style.slice(index);
        var delimiter = trimmedStyle.indexOf(';');

        // Remove "transform" string and save the attribute
        if (delimiter) {
          transform = " " + trimmedStyle.slice(11, delimiter).replace(/\s/g,'');
        } else {
          transform = " " + trimmedStyle.slice(11).replace(/\s/g,'');
        }
      }

      return {
        baseX: bases.x,
        baseY: bases.y,
        top: blockTop,
        left: blockLeft,
        height: blockHeight,
        width: blockWidth,
        speed: speed,
        style: style,
        transform: transform,
        zindex: dataZindex,
        min: dataMin,
        max: dataMax
      };
    };

    // set scroll position (posY, posX)
    // side effect method is not ideal, but okay for now
    // returns true if the scroll changed, false if nothing happened
    var setPosition = function() {
      var oldY = posY;
      var oldX = posX;

      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;
      // If option relativeToWrapper is true, use relative wrapper value instead.
      if (self.options.relativeToWrapper) {
        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
        posY = scrollPosY - self.options.wrapper.offsetTop;
      }


      if (oldY != posY && self.options.vertical) {
        // scroll changed, return true
        return true;
      }

      if (oldX != posX && self.options.horizontal) {
        // scroll changed, return true
        return true;
      }

      // scroll did not change
      return false;
    };

    // Ahh a pure function, gets new transform value
    // based on scrollPosition and speed
    // Allow for decimal pixel values
    var updatePosition = function(percentageX, percentageY, speed) {
      var result = {};
      var valueX = (speed * (100 * (1 - percentageX)));
      var valueY = (speed * (100 * (1 - percentageY)));

      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;
      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;

      return result;
    };

    // Loop
    var update = function() {
      if (setPosition() && pause === false) {
        animate();
      }

      // loop again
      loopId = loop(update);
    };

    // Transform3d on parallax element
    var animate = function() {
      var positions;
      for (var i = 0; i < self.elems.length; i++){
        var percentageY = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));
        var percentageX = ((posX - blocks[i].left + screenX) / (blocks[i].width + screenX));

        // Subtracting initialize value, so element stays in same spot as HTML
        positions = updatePosition(percentageX, percentageY, blocks[i].speed);// - blocks[i].baseX;
        var positionY = positions.y - blocks[i].baseY;
        var positionX = positions.x - blocks[i].baseX;

        // The next two "if" blocks go like this:
        // Check if a limit is defined (first "min", then "max");
        // Check if we need to change the Y or the X
        // (Currently working only if just one of the axes is enabled)
        // Then, check if the new position is inside the allowed limit
        // If so, use new position. If not, set position to limit.

        // Check if a min limit is defined
        if (blocks[i].min !== null) {
          if (self.options.vertical && !self.options.horizontal) {
            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;
          }
          if (self.options.horizontal && !self.options.vertical) {
            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;
          }
        }

        // Check if a max limit is defined
        if (blocks[i].max !== null) {
          if (self.options.vertical && !self.options.horizontal) {
            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;
          }
          if (self.options.horizontal && !self.options.vertical) {
            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;
          }
        }

        var zindex = blocks[i].zindex;

        // Move that element
        // (Set the new translation and append initial inline transforms.)

        if(!self.options.horizontal) {
          var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;
        } else {


          if ( (blocks[i].speed < 0) && (positionY < 0) ) {
            var translate = 'translate3d(' + (self.options.vertical ? positionY : '0') + 'px,' + '0px,' + zindex + 'px) ' + blocks[i].transform;
          } else if( (blocks[i].speed > 0) && (positionY > 0) ) {
            var translate = 'translate3d(' + (self.options.vertical ? positionY : '0') + 'px,' + '0px,' + zindex + 'px) ' + blocks[i].transform;
          }


        }

        // var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;
        // var translate = 'translate3d(' + (self.options.vertical ? positionY : '0') + 'px,' + (self.options.horizontal ? positionX : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;
        //var translate = 'translate3d(' + (self.options.vertical ? positionX : '0') + 'px,' + '0' + 'px,' + zindex + 'px) ' + blocks[i].transform;

        self.elems[i].style[transformProp] = translate;
      }
      self.options.callback(positions);
    };

    self.destroy = function() {
      for (var i = 0; i < self.elems.length; i++){
        self.elems[i].style.cssText = blocks[i].style;
      }

      // Remove resize event listener if not pause, and pause
      if (!pause) {
        window.removeEventListener('resize', init);
        pause = true;
      }

      // Clear the animation loop to prevent possible memory leak
      clearLoop(loopId);
      loopId = null;
    };

    // Init
    init();

    // Start the loop
    update();

    // Allow to recalculate the initial values whenever we want
    self.refresh = init;

    return self;
  };
  return Rellax;
}));











///////////////////////////////
// HELPERS
///////////////////////////////
function getUrlParameter(name) {
  name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
  var results = regex.exec(location.search);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};

function getHashValue(key) {
  var matches = location.hash.match(new RegExp(key+'=([^&]*)'));
  return matches ? matches[1] : null;
}

function isMobile(){
  return (
    (navigator.userAgent.match(/Android/i)) ||
		(navigator.userAgent.match(/webOS/i)) ||
		(navigator.userAgent.match(/iPhone/i)) ||
		(navigator.userAgent.match(/iPod/i)) ||
		(navigator.userAgent.match(/iPad/i)) ||
		(navigator.userAgent.match(/IEMobile/i)) ||
		(navigator.userAgent.match(/BlackBerry/))
  );
}




///////////////////////////////
// Waypoints
///////////////////////////////
function waypointsInit() {

  var body = document.getElementsByTagName("BODY")[0];
  if(body.classList.contains('global__interactive__item__waypionts') &&  !body.classList.contains('global__interactive__parallax') ) {
    // var itemQueue = []
    // var delay = 50
    // var queueTimer
    //
    // function processItemQueue () {
    //   if (queueTimer) return // We're already processing the queue
    //   queueTimer = window.setInterval(function () {
    //     if (itemQueue.length) {
    //       $(itemQueue.shift()).addClass('show');
    //       processItemQueue()
    //     }
    //     else {
    //       window.clearInterval(queueTimer)
    //       queueTimer = null
    //     }
    //   }, delay)
    // }

    // var continuousElements = document.getElementsByClassName('js__section')
    // for (var i = 0; i < continuousElements.length; i++) {
    //   new Waypoint({
    //     element: continuousElements[i],
    //     // context: document.getElementById('wrapper'),
    //     handler: function() {
    //       // notify(this.element.innerHTML + ' hit')
    //       var section_element = this.element;
    //
    //
    //
    //       var items = continuousElements[i].getElementsByClassName('js__item');
    //
    //       console.log(items);
    //
    //       var section_items = continuousElements[i].getElementsByClassName('js__item');
    //       for (var i = 0; i < section_items.length; i++) {
    //         // section_items[i].waypoint( function () { itemQueue.push(this.element) processItemQueue() }, { offset: '95%' });
    //         new Waypoint({
    //           element: section_items[i],
    //           // context: document.getElementById('wrapper'),
    //           handler: function() {
    //             this.element.addClass('show')
    //           },
    //           offset: '100%'
    //         })
    //       }
    //
    //       // $(".js__item").waypoint( function () { itemQueue.push(this.element) processItemQueue() }, { offset: '95%' });
    //
    //
    // 			this.destroy();
    //     },
    //     offset: '95%'
    // 		// offset: 'top-in-view'
    // 		// offset: 'bottom-in-view',
    // 		// continuous: false
    //   })
    // }

    (function($) {
      var itemQueue = []
      var delay = 100
      var queueTimer

      function processItemQueue () {
        if (queueTimer) return // We're already processing the queue
    		queueTimer = window.setInterval(function () {
          if (itemQueue.length) {
            $(itemQueue.shift()).addClass('show');
            processItemQueue()
          }
          else {
            window.clearInterval(queueTimer)
            queueTimer = null
          }
        }, delay)
      }


      // var main_sections = $("main section");
      // for (var i = 0; i < main_sections.length; i++) {
      //   console.log(main_sections[i].id);
      //
      //   var itemQueue = []
      //   var delay = 50
      //   var queueTimer
      //
      //   function processItemQueue () {
      //     if (queueTimer) return // We're already processing the queue
      // 		queueTimer = window.setInterval(function () {
      //       if (itemQueue.length) {
      //         $(itemQueue.shift()).addClass('show');
      //         processItemQueue()
      //       }
      //       else {
      //         window.clearInterval(queueTimer)
      //         queueTimer = null
      //       }
      //     }, delay)
      //   }
      //
      //
      //   if(main_sections[i].id) {
      //     $( "#" + main_sections[i].id + " .js__item").waypoint(function () {
      //       itemQueue.push(this.element)
      //       processItemQueue()
      //     }, {
      //       offset: '95%'
      //     })
      //   }
      //
      // }


      $(".js__item").waypoint(function () {
        itemQueue.push(this.element)
        processItemQueue()
      }, {
        offset: '95%'
      })






    //   $(".js__content p").waypoint(function () {
    //     itemQueue.push(this.element)
    //     processItemQueue()
    //   }, {
    //     offset: '95%'
    //   })
    //

      var sectionQueue = []
      var delay = 200
      var sectionQueueTimer

      function processSectionQueue () {
        if (sectionQueueTimer) return // We're already processing the queue
    		sectionQueueTimer = window.setInterval(function () {
          if (sectionQueue.length) {
            $(sectionQueue.shift()).addClass('waypoint__active');
            processSectionQueue()
          }
          else {
            window.clearInterval(sectionQueueTimer)
            sectionQueueTimer = null
          }
        }, delay)
      }

      // $(".js__section").waypoint(function () {
      //   sectionQueue.push(this.element)
      //   processSectionQueue()
      // }, {
      //   offset: '95%'
      // })

    })(jQuery);







  	// if (document.getElementById("ajaxProjectFilter")) {
  	// 	var waypoint = new Waypoint({
  	// 	  element: document.getElementById('ajaxProjectFilter'),
  	// 	  handler: function(direction) {
  	// 	    // console.log('Scrolled to waypoint!');
  	// 			var pName = jQuery('#ajaxProjectFilter').attr('data-filter');
  	// 			loadProject('single', pName, 'desktop' );
  	// 			this.destroy();
  	// 	  },
  	// 		offset: 'bottom-in-view'
  	// 	})
  	// }

  	// var continuousElements = document.getElementsByClassName('js__section')
  	// for (var i = 0; i < continuousElements.length; i++) {
  	//   new Waypoint({
  	//     element: continuousElements[i],
    //     // context: document.getElementById('wrapper'),
  	//     handler: function() {
  	//       // notify(this.element.innerHTML + ' hit')
    //       var section_element = this.element;
    //       setTimeout(function(){ section_element.classList.add('waypoint__active'); }, 10);
    //
    //       TweenMax.to(this.element.getElementsByClassName('js__heading'), .5,{ ease:  Sine.easeInOut, css:{opacity:1} })
    //       TweenMax.to(this.element.getElementsByClassName('js__heading'), .8,{ y:'0%', delay: 0.0, ease:  Sine.easeInOut })
    //       TweenMax.to(this.element.getElementsByClassName('js__ui_line'), .5,{delay:0.5,  ease:  Sine.easeInOut, css:{width: '100%' } })
    //
  	// 			this.destroy();
  	//     },
    //     offset: '95%'
  	// 		// offset: 'top-in-view'
  	// 		// offset: 'bottom-in-view',
    // 		// continuous: false
  	//   })
  	// }

    // var continuousElements = document.getElementsByClassName('js__item')
  	// for (var i = 0; i < continuousElements.length; i++) {
  	//   new Waypoint({
  	//     element: continuousElements[i],
    //     // context: document.getElementById('wrapper'),
  	//     handler: function() {
    //       TweenMax.to(this.element, .2,{ ease: 'Strong.ease', css:{opacity:1} })
    //       TweenMax.to(this.element, .5,{ y:'0%', delay: 0.0, ease: 'Strong.ease' })
  	// 			this.destroy();
  	//     },
    //     offset: '100%'
  	//   })
  	// }
    //
    // var continuousElements = document.getElementsByClassName('js__content')
  	// for (var i = 0; i < continuousElements.length; i++) {
    //
    //   var paragraphs = continuousElements[i].getElementsByTagName("p");
    //   for (var c = 0; c < paragraphs.length; c++) {
    // 	  new Waypoint({
    // 	    element: paragraphs[c],
    // 	    handler: function() {
    //         var delay = c * 0;
    //         console.log(delay);
    //         console.log(c);
    //         TweenMax.to(this.element, .5,{ ease: 'Strong.ease', css:{opacity:1} })
    //         TweenMax.to(this.element, 1,{ y:'0%', delay: delay, ease: 'Strong.ease' })
    // 				this.destroy();
    // 	    },
    //       offset: '95%'
    // 	  })
    // 	}
    //
  	// }
  }
}


///////////////////////////////
// FAST CLICK
///////////////////////////////
function fastclickInit() {
	if ('addEventListener' in document) {
    document.addEventListener('DOMContentLoaded', function() {
        FastClick.attach(document.body);
    }, false);
	}
}





///////////////////////////////
// INIT
///////////////////////////////
function init() {
  // Waypoint.destroyAll();
	fastclickInit();
  waypointsInit();

}





// if (document.getElementById("video-foreground") && !isMobile()) {
//
//   var player;
//   var XT = XT || {};
//
//   window.onYouTubeIframeAPIReady = function(){
//       setTimeout(XT.yt.onYouTubeIframeAPIReady,500);
//   }
//
//   XT.yt = {
//
//   /* load the YouTube API first */
//   loadApi: function () {
//
//           var j = document.createElement("script"),
//               f = document.getElementsByTagName("script")[0];
//           j.src = "//www.youtube.com/iframe_api";
//           j.async = true;
//           f.parentNode.insertBefore(j, f);
//           console.log('API Loaded');
//       },
//
//   /*default youtube api listener*/
//   onYouTubeIframeAPIReady: function () {
//       console.log('API Ready?');
//       window.YT = window.YT || {};
//       if (typeof window.YT.Player === 'function') {
//         player = new YT.Player('video-foreground', {
//           videoId: 'rkCPnzPzweY', // YouTube Video ID
//           playerVars: {
//             autoplay: 1,        // Auto-play the video on load
//             controls: 0,        // Show pause/play buttons in player
//             showinfo: 0,        // Hide the video title
//             modestbranding: 1,  // Hide the Youtube Logo
//             loop: 1,            // Run the video in a loop
//             fs: 0,              // Hide the full screen button
//             cc_load_policy: 0, // Hide closed captions
//             iv_load_policy: 3,  // Hide the Video Annotations
//             autohide: 0,         // Hide video controls when playing
//             playlist: 'rkCPnzPzweY'
//           },
//           events: {
//             onReady: function(e) {
//               e.target.mute();
//             }
//           }
//         });
//       }
//   },
//
//   onPlayerReady: function() {
//     player.playVideo(); /* start the video */
//     player.setVolume(1); /* set volume to 1 (accepts 0-100) */
//   },
//
//   onPlayerStateChange: function (e) {
//       console.log(e.data, YT.PlayerState.PLAYING, e.data === YT.PlayerState.PLAYING);
//       var video_data = e.target.getVideoData();
//
//       //do something on video ends
//       if(e.data === YT.PlayerState.ENDED)
//       this.onPlayerStop();
//   },
//
//   onPlayerStop: function(){
//       //console.log('video ended');
//   },
//
//   onPlayerError: function (e) {
//       console.log( "youtube: " + e.target.src + " - " + e.data);
//   },
//
//   init: function () {
//       this.loadApi();
//   }
//
//   }
//
//   XT.yt.init();
// }




///////////////////////////////
// Initialize
///////////////////////////////
jQuery.noConflict();
jQuery(document).ready(function() {

init();


// (function($){
// // Select all links with hashes
// $('a[href*="#"]')
// // Remove links that don't actually link to anything
// .not('[href="#"]')
// .not('[href="#0"]')
// .click(function(event) {
//   // On-page links
//   if (
//     location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '')
//     &&
//     location.hostname == this.hostname
//   ) {
//     // Figure out element to scroll to
//     var target = $(this.hash);
//     target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
//     // Does a scroll target exist?
//     if (target.length) {
//
//       console.log(target.offset().top);
//       // Only prevent default if animation is actually gonna happen
//       event.preventDefault();
//       $('html, body').animate({
//         scrollTop: target.offset().top
//       }, 1000, function() {
//         // Callback after animation
//         // Must change focus!
//         var $target = $(target);
//         $target.focus();
//         if ($target.is(":focus")) { // Checking if the target was focused
//           return false;
//         } else {
//           $target.attr('tabindex','-1'); // Adding tabindex for elements not focusable
//           $target.focus(); // Set focus again
//         };
//       });
//     }
//   }
// });
// })(jQuery);

/////////////////////////////////
// Auto Scroll
/////////////////////////////////
(function($){

  $('a[href^="#"]').bind('click.smoothscroll', function(e) {
    console.log('autoscroll');
    e.preventDefault();

    // Get the current target hash
    var target = this.hash;
    var offset = $('#menu__pena__nav__main_fixed').height();

    if (this.hasAttribute("data-offset")) {
      offset = this.getAttribute('data-offset');
    }

    var menuHeight = offset;

    // Animate the scroll bar action so its smooth instead of a hard jump
    $('html, body').stop().animate({
        'scrollTop' : $(target).offset().top - (menuHeight * 2)
    }, 900, 'swing', function() {
        window.location.hash = target;
    });


  });

})(jQuery);


/////////////////////////////////
// Auto Scroll / ABSOLUTE BODY
/////////////////////////////////
// (function($){
//   var body = document.getElementsByTagName("BODY")[0];
//   if(!body.classList.contains('global__interactive__parallax') ) {
//     $('a[href^="#"]').bind('click.smoothscroll', function(e) {
//         e.preventDefault();
//
//         // Get the current target hash
//         var target = this.hash;
//         var offset = $('#menu__pena__nav__main_fixed').height();
//
//         if (this.hasAttribute("data-offset")) {
//           offset = this.getAttribute('data-offset');
//         }
//
//         var menuHeight = offset;
//
//         // Animate the scroll bar action so its smooth instead of a hard jump
//         $('html, body').stop().animate({
//             'scrollTop' : $(target).offset().top - (menuHeight * 2)
//         }, 900, 'swing', function() {
//             window.location.hash = target;
//         });
//     });
//
//   } else {
//
//     function scrollTo(element, to, duration) {
//        var start = element.scrollTop,
//            change = to - start,
//            currentTime = 0,
//            increment = 20;
//
//        var animateScroll = function(){
//            currentTime += increment;
//            var val = Math.easeInOutQuad(currentTime, start, change, duration);
//            element.scrollTop = val;
//            if(currentTime < duration) {
//                setTimeout(animateScroll, increment);
//            }
//        };
//        animateScroll();
//     }
//
//     //t = current time
//     //b = start value
//     //c = change in value
//     //d = duration
//     Math.easeInOutQuad = function (t, b, c, d) {
//      t /= d/2;
//      if (t < 1) return c/2*t*t + b;
//      t--;
//      return -c/2 * (t*(t-2) - 1) + b;
//     };
//
//     $('a[href^="#"]').bind('click', function(e) {
//         e.preventDefault();
//         console.log('click autoscroll')
//         var container = this.hash.substring(1);
//         var elem = document.getElementById(container);
//         var topPos = elem.offsetTop;
//         console.log(container);
//
//
//         scrollTo(document.getElementById('wrapper'), topPos, 600);
//     });
//
//
//
//
//   } // End if
//
// })(jQuery);






/////////////////////////////////
// LAZY LOAD IMAGES
/////////////////////////////////
// new Blazy({
// 	success: function(){ }
// });



//////////////////////////////////////////////////////////////////
// VISION STICKY NAV
//////////////////////////////////////////////////////////////////
function initVisionNav () {
  var body = document.getElementsByTagName("BODY")[0];
  if(!body.classList.contains('global__interactive__parallax') ) {
    if (document.getElementById("section__vision__nav")) {

      var children = $("#section__vision__nav li").children();
      var tab = [];
      for (var i=0; i < children.length; i++) {
        console.log(children[i]);
        var child = children[i];
        var ahref = $(child).attr('href');
        console.log(ahref);
        tab.push(ahref);
      }

      $(window).scroll( function() {
        var windowScrollTop = $(window).scrollTop();
        var windowHeight = $(window).height();
        var docHeight = $(document).height();
        var menuHeight = $('#menu__pena__nav__main_fixed').height();

        for (var i=0; i < tab.length; i++) {
            var link = tab[i];
            var divPos = $(link).offset().top  - (menuHeight * 3);
            var divHeight = $(link).height();
            if (windowScrollTop >= divPos && windowScrollTop < (divPos + divHeight)) {
                $("#section__vision__nav a[href='" + link + "']").addClass("active");
            } else {
                $("#section__vision__nav a[href='" + link + "']").removeClass("active");
            }
        }

        if(windowScrollTop + windowHeight == docHeight) {
          if (!$("#section__vision__nav li:last-child a").hasClass("active")) {
            var navActive = $(".active").attr("href");
            $("#section__vision__nav a[href='" + navActive + "']").removeClass("active");
            $("#section__vision__nav li:last-child a").addClass("active");
          }
        }
      });
    }
  }
}

initVisionNav();


//////////////////////////////////////////////////////////////////
// HOME SLIDESHOW NAV
//////////////////////////////////////////////////////////////////
function initSliderNav () {
  var body = document.getElementsByTagName("BODY")[0];
  if(!body.classList.contains('global__interactive__parallax') ) {
    if (document.getElementById("section__home__slides__nav")) {

      var children = $("#section__home__slides__nav li").children();
      var tab = [];
      for (var i=0; i < children.length; i++) {
        // console.log(children[i]);
        var child = children[i];
        var ahref = $(child).attr('href');
        var nav_color = $(child).attr('data-color');

        // console.log(ahref);
        // console.log(nav_color);

        tab.push([ahref, nav_color]);
      }

      console.log(tab);
      console.log(tab[0][0]);
      console.log(tab[0][1]);

      $(window).scroll( function() {
        var windowScrollTop = $(window).scrollTop();
        var windowHeight = $(window).height();
        var docHeight = $(document).height();
        var menuHeight = $('#menu__pena__nav__main_fixed').height();

        for (var i=0; i < tab.length; i++) {
            var link = tab[i][0];
            var color = tab[i][1];
            var divPos = $(link).offset().top  - (menuHeight * 3);
            var divHeight = $(link).height();
            if (windowScrollTop >= divPos && windowScrollTop < (divPos + divHeight)) {

                $("#section__home__slides__nav ul").attr('class', 'txc__' + color);

                $("#section__home__slides__nav a[href='" + link + "']").addClass("active");
            } else {
                $("#section__home__slides__nav a[href='" + link + "']").removeClass("active");
            }
        }

        if(windowScrollTop + windowHeight == docHeight) {
          if (!$("#section__home__slides__nav li:last-child a").hasClass("active")) {
            var navActive = $(".active").attr("href");
            $("#section__home__slides__nav a[href='" + navActive + "']").removeClass("active");
            $("#section__home__slides__nav li:last-child a").addClass("active");
          }
        }
      });
    }
  }
}

initSliderNav();


// //////////////////////////////////////////////////////////////////
// // HOME SLIDESHOW NAV
// //////////////////////////////////////////////////////////////////
// function initSliderNav () {
//   var body = document.getElementsByTagName("BODY")[0];
//   if(!body.classList.contains('global__interactive__parallax') ) {
//     if (document.getElementById("section__home__slides__nav")) {
//
//       var children = $("#section__home__slides__nav li").children();
//       var tab = [];
//       for (var i=0; i < children.length; i++) {
//         console.log(children[i]);
//         var child = children[i];
//         var ahref = $(child).attr('href');
//         var nav_color = $(child).attr('data-color');
//
//         console.log(ahref);
//         console.log(nav_color);
//
//         tab.push(ahref);
//       }
//
//       $(window).scroll( function() {
//         var windowScrollTop = $(window).scrollTop();
//         var windowHeight = $(window).height();
//         var docHeight = $(document).height();
//         var menuHeight = $('#menu__pena__nav__main_fixed').height();
//
//         for (var i=0; i < tab.length; i++) {
//             var link = tab[i];
//             var divPos = $(link).offset().top  - (menuHeight * 3);
//             var divHeight = $(link).height();
//             if (windowScrollTop >= divPos && windowScrollTop < (divPos + divHeight)) {
//                 $("#section__home__slides__nav a[href='" + link + "']").addClass("active");
//             } else {
//                 $("#section__home__slides__nav a[href='" + link + "']").removeClass("active");
//             }
//         }
//
//         if(windowScrollTop + windowHeight == docHeight) {
//           if (!$("#section__home__slides__nav li:last-child a").hasClass("active")) {
//             var navActive = $(".active").attr("href");
//             $("#section__home__slides__nav a[href='" + navActive + "']").removeClass("active");
//             $("#section__home__slides__nav li:last-child a").addClass("active");
//           }
//         }
//       });
//     }
//   }
// }
//
// initSliderNav();




var body = document.getElementsByTagName("BODY")[0];
if(body.classList.contains('global__interactive__item__waypionts') &&  body.classList.contains('global__interactive__parallax') ) {

  var continuousElements = document.getElementsByClassName('js__section')
  for (var i = 0; i < continuousElements.length; i++) {
    new Waypoint({
      element: continuousElements[i],
      context: document.getElementById('wrapper'),
      handler: function() {
        // notify(this.element.innerHTML + ' hit')
        var section_element = this.element;
        setTimeout(function(){ section_element.classList.add('waypoint__active'); }, 10);
  			this.destroy();
      },
      // offset: '95%'
  		// offset: 'top-in-view'
  		offset: '20%',
  		// continuous: false
    })
  }

} else if(body.classList.contains('global__interactive__item__waypionts')) {

  var continuousElements = document.getElementsByClassName('js__section')
  console.log('js__section');
  for (var i = 0; i < continuousElements.length; i++) {
    new Waypoint({
      element: continuousElements[i],
      handler: function() {
        // notify(this.element.innerHTML + ' hit')
        var section_element = this.element;
        setTimeout(function(){ section_element.classList.add('waypoint__active'); }, 10);
  			this.destroy();
      },
      // offset: '95%'
  		// offset: 'top-in-view'
  		offset: '20%',
  		// continuous: false
    })
  }

}




/////////////////////////////////
// PARALLAX HEROS
/////////////////////////////////
// (function($){
//   $(window).scroll(function() {
//     var sTop = $(window).scrollTop();
//
//     $('[data-transition]').each(function() {
//       var transition = (sTop / parseFloat($(this).data('transition'))) * -1;
//       $(this).css({
//         '-webkit-transform': 'translateY(' + transition + 'px)',
//         '-ms-transform': 'translateY(' + transition + 'px)',
//         'transform': 'translateY(' + transition + 'px)'
//       });
//     });
//
//     //
//     $('[data-opacity]').each(function() {
//       if ($(this).data('opacity') < 1) {
//         var transition = 1 + ((sTop / parseFloat($(this).data('opacity'))) / 500);
//       } else {
//         var transition = (sTop / parseFloat($(this).data('opacity'))) / 500;
//       }
//       $(this).css('opacity', transition );
//     });
//
//   });
// })(jQuery);

/////////////////////////////////
// HOME PARALLAX
/////////////////////////////////
// (function () {
//   if(!isMobile()){
//     var win = jQuery(window);
// 		var doc = jQuery(document);
//     var Title = jQuery('.text');
//     var Shade = jQuery('.shade');
//     // var bgHeight = 1200;
//
//     var docHeight, winHeight, maxScroll;
//     function onResize(){
// 			docHeight = doc.height();
//       bgHeight = docHeight;
// 			winHeight = win.height();
// 			maxScroll = docHeight - winHeight;
// 			moveParallax();
// 		}
//     function moveParallax(){
//       var Num = win.scrollTop() / 500;
// 			// var bgYPos = -(bgHeight-winHeight)* (win.scrollTop() / maxScroll);
//       // var textYPos = -(win.scrollTop() * .6);
//       var textYPos = (win.scrollTop() * .2);
//
//       return TweenMax.to(Shade, 0.1,{ css:{opacity: Num } }),
// 			TweenLite.to(Title, 0.1, {y: textYPos + "px"});
//
// 		}
//
//     win.on("scroll", moveParallax).on("resize", onResize).resize();
//   }
// }.call(this));



var body = document.getElementsByTagName("BODY")[0];
if(body.classList.contains('global__interactive__parallax') ) {
  const scroller = document.getElementById('wrapper');
  scroller.addEventListener("scroll", function scrolling() {
    let height = scroller.clientHeight;
    let scrollHeight = scroller.scrollHeight - height;
    let scrollTop = scroller.scrollTop;
    let percent = Math.floor(scrollTop / scrollHeight * 100);
    // document.getElementById('percent').innerText = 'Percent : '+percent+'%';
    console.log(percent);
    let scrollProgressValue = document.querySelector(".scroll-progress-value");
      scrollProgressValue.style.height = percent + "%";
  });
} else {

  if (document.getElementById("progress__bar")) {
    console.log('Start progress__bar...');
    window.addEventListener("scroll", function scrollProgress() {
      let bodyScrollTop = window.pageYOffset;
      let viewportHeight = window.innerHeight;
      //let totalBodyHeight = document.body.clientHeight;
      let totalBodyHeight = document.body.scrollHeight
      let scrollArea = totalBodyHeight - viewportHeight;
      let scrollPercentage = (100 / scrollArea ) * bodyScrollTop;
      let scrollProgressValue = document.querySelector(".scroll-progress-value");
        scrollProgressValue.style.height = scrollPercentage + "%";
      //- let scrollBoxValue = document.querySelector(".scroll-box-value");
      //-   scrollBoxValue.innerHTML = Math.round(scrollPercentage);

    });
  }

}

(function($){

  if ($('.rellax')[0]) {
    // console.log('rellax');
    var rellax_1 = new Rellax('.rellax', {
      center: true
    });
  }

  if ($('.rellax__h')[0]) {
    // console.log('rellax__h');
    var rellax_1 = new Rellax('.rellax__h', {
      center: true,
      horizontal: true
    });
  }




  // if ($('.rellax__2')[0]) {
  //   var rellax_2 = new Rellax('.rellax__2', {
  //     center: true,
  //     wrapper: '.rellax__wrapper__2'
  //   });
  // }

})(jQuery);


});
